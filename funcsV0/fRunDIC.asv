function [RegOutput]= fRunDIC(Image_ref,Image_test,setXCF,fitfunc,dx,dy)
%% Unpack inputs
roiSize =setXCF.ROISize;
%% run  main functions
%set up ROIs
% set up the filter windows, boundary
% filters = round([log2(roiSize)/2,log2(roiSize)/4,2*log2(roiSize),log2(roiSize)]);
Filters_setting = [0;0;round(roiSize/2);round(roiSize/4)];
[FFTfilter,hfilter] = fFilters(roiSize,Filters_setting);
% TODO: MOVE TO pairShifts CLASS
% % spread out the subregions in the defined ROI and set up the position of ROIs
[rowvals,colvals]=find(~(isnan(Image_ref)).*(~isnan(Image_test))==1);
xmin=min(colvals);
ymin=min(rowvals);
xmax=max(colvals);
ymax=max(rowvals);
boundary = [xmin+1,ymin+1,xmax-xmin-1,ymax-ymin-1]; %[left edge top edge width height], like imcrop.
[roiPosX, roiPosY,roiCoord,roiNum] = fDIC_ROI_position(roiSize,setXCF.NumROI,boundary);

% create temporary ROI structure (TODO - repack this into setXCF for
% fDIC_xcf_mat)
ROI = struct;
ROI.size_pass_1 =roiSize;
ROI.position_X_pass_1=roiPosX;
ROI.position_Y_pass_1=roiPosY;
ROI.coordinator_pass_1=roiCoord;
ROI.num_pass_1 = roiNum;
ROI.num_x_pass_1 = numel(ROI_posi_x); %delete if not needed
ROI.num_y_pass_1 = numel(ROI_posi_y);

% perform the XCF and determine shift in x  shift in y and peak height
try
    [xShiftsXcf,yShiftsXcf,CCmax_1] = fDIC_xcf_mat_mex(Image_ref,Image_test,ROI,Filters_setting,setXCF.XCFMesh,hfilter,FFTfilter);
catch
    % %replace with the next line if fDIC_xcf_mat_mex doesn't work
    [xShiftsXcf,yShiftsXcf,CCmax_1] = fDIC_xcf_mat(Image_ref,Image_test,ROI,Filters_setting,setXCF.XCFMesh,hfilter,FFTfilter);
    warning('Mex file error in fDIC_xcf_mat_mex. Check the mex file for your operating system. Mex file compiled using MATLAB version 2025a.');
end
%% fit a surface to the shift vector
% figure, imagesc(xShiftsXcf); axis equal; caxis([-15 -5]);
% figure, imagesc(yShiftsXcf); axis equal; caxis([-5 5]);

% roiPosX and roiPosY are the ROI centre locations
switch fitfunc
    case 'poly11'
    %remove values with NaN XCF height
    xShiftsXcf=xShiftsXcf(~isnan(CCmax_1));
    yShiftsXcf=yShiftsXcf(~isnan(CCmax_1));
    roiPosX=roiPosX(~isnan(CCmax_1));
    roiPosY=roiPosY(~isnan(CCmax_1));
    CCmax=CCmax_1(~isnan(CCmax_1));

    % calculate best fit
    [xsurf, ~]=fit([roiPosX(:),roiPosY(:)],xShiftsXcf(:),fitfunc,'Robust','Bisquare','Weights',CCmax);
    [ysurf, ~]=fit([roiPosX(:),roiPosY(:)],yShiftsXcf(:),fitfunc,'Robust','Bisquare','Weights',CCmax);
    RegOutput.transMat = [xsurf.p10+1,xsurf.p01,xsurf.p00;
        ysurf.p10,ysurf.p01+1,ysurf.p00;
        0,0,1];
    
    %for quiver plot
    xshiftsROI=xsurf(roiPosX,roiPosY);
    yshiftsROI=ysurf(roiPosX,roiPosY);
    
    % for entire image
    [Xpixels,Ypixels]=meshgrid(1:size(Image_ref,2),1:size(Image_ref,1)); %pixel grid in reference frame
    xshifts=xsurf(Xpixels,Ypixels); %pixel shifts in reference frame
    yshifts=ysurf(Xpixels,Ypixels);
    
    case 'poly22'
    %remove values with NaN XCF height
    xShiftsXcf=xShiftsXcf(~isnan(CCmax_1));
    yShiftsXcf=yShiftsXcf(~isnan(CCmax_1));
    roiPosX=roiPosX(~isnan(CCmax_1));
    roiPosY=roiPosY(~isnan(CCmax_1));
    CCmax=CCmax_1(~isnan(CCmax_1));

    % calculate best fit
    [xsurf, ~]=fit([roiPosX(:),roiPosY(:)],xShiftsXcf(:),fitfunc,'Robust','Bisquare','Weights',CCmax);
    [ysurf, ~]=fit([roiPosX(:),roiPosY(:)],yShiftsXcf(:),fitfunc,'Robust','Bisquare','Weights',CCmax);
    
    
    %for quiver plot
    xshiftsROI=xsurf(roiPosX,roiPosY);
    yshiftsROI=ysurf(roiPosX,roiPosY);
    
    % for entire image
    [Xpixels,Ypixels]=meshgrid(1:size(Image_ref,2),1:size(Image_ref,1)); %pixel grid in reference frame
    xshifts=xsurf(Xpixels,Ypixels); %pixel shifts in reference frame
    yshifts=ysurf(Xpixels,Ypixels);
    
    
    case 'linearinterp'
    CCmax=reshape(CCmax_1,size(roiCoord));
    shiftX_temp=nan(size(CCmax));
    shiftY_temp=shiftX_temp;
    shiftX_temp(~isnan(CCmax))=xShiftsXcf(~isnan(CCmax));
    shiftY_temp(~isnan(CCmax))=yShiftsXcf(~isnan(CCmax));
    
    % calculate best fit
    shiftX_rows=median(shiftX_temp,2,'omitnan');
    shiftY_rows=median(shiftY_temp,2,'omitnan');
    
    nancheck=isnan(shiftX_rows) | isnan(shiftY_rows);
    
    roiPosY(nancheck,:)=[];
    roiPosX(nancheck,:)=[];
    shiftX_rows(nancheck)=[];
    shiftY_rows(nancheck)=[];
    xShiftsXcf(nancheck,:)=[];
    yShiftsXcf(nancheck,:)=[];

    
    
    [xfit, ~]=fit(roiPosY(:,1),shiftX_rows(:),fitfunc);
    [yfit, ~]=fit(roiPosY(:,1),shiftY_rows(:),fitfunc);
    
    %for quiver plot
    xshifts_lineROI=xfit(roiPosY(:,1));
    yshifts_lineROI= yfit(roiPosY(:,1));
    xshiftsROI=repmat(xshifts_lineROI(:),1,size(roiPosY,2));
    yshiftsROI=repmat(yshifts_lineROI(:),1,size(roiPosY,2));
    
    
    % for entire image
%     [Xpixels,Ypixels]=meshgrid(1:size(Image_ref,2),1:size(Image_ref,1)); %pixel grid in reference frame
    Ypixels_line=1:size(Image_ref,1);
    xshifts_line=xfit(Ypixels_line);
    yshifts_line= yfit(Ypixels_line);
    
    xshifts = repmat(xshifts_line(:),1,size(Image_ref,2));
    yshifts = repmat(yshifts_line(:),1,size(Image_ref,2));
    
    
    case 'projective'
    %remove values with NaN XCF height
    xShiftsXcf=xShiftsXcf(~isnan(CCmax_1));
    yShiftsXcf=yShiftsXcf(~isnan(CCmax_1));
%     CCmax=CCmax_1(~isnan(CCmax_1));
    roiPosX=roiPosX(~isnan(CCmax_1));
    roiPosY=roiPosY(~isnan(CCmax_1));
    
    % calculate best fit
    zeromat=zeros(numel(roiPosX),1);
    onesmat=zeromat+1;
    
    lhs_mat=[roiPosX(:), roiPosY(:),onesmat(:), ...
        zeromat(:), zeromat(:), zeromat(:), ...
        -(roiPosX(:).*(roiPosX(:)-xShiftsXcf(:))) ...
        -(roiPosY(:).*(roiPosX(:)-xShiftsXcf(:)));
        
        zeromat(:), zeromat(:), zeromat(:),...
        roiPosX(:), roiPosY(:), onesmat(:), ...
        -(roiPosX(:).*(roiPosY(:)-yShiftsXcf(:))) ...
        -(roiPosY(:).*(roiPosY(:)-yShiftsXcf(:)))];
    
    rhs_mat=[(roiPosX(:)-xShiftsXcf(:));
        (roiPosY(:)-yShiftsXcf(:))];
    
    [rottrans_mat,~] = robustfit(lhs_mat,rhs_mat,'bisquare',4.685,0); %like wmd solution
    rottrans_mat=reshape([rottrans_mat(:);1],3,3)';
    
    %for quiver plot
    onesmatgrid=ones(size(roiPosX));
    transgridROI=rottrans_mat*([roiPosX(:) roiPosY(:) onesmatgrid(:)])';
    transgridxROI=reshape(transgridROI(1,:),size(roiPosX,1),size(roiPosX,2));
    transgridyROI=reshape(transgridROI(2,:),size(roiPosX,1),size(roiPosX,2));
    xshiftsROI=roiPosX-transgridxROI;
    yshiftsROI=roiPosY-transgridyROI;
    
    % for entire image
    [Xpixels,Ypixels]=meshgrid(1:size(Image_ref,2),1:size(Image_ref,1)); %Data grid
    onesmatgrid=ones(size(Image_ref));
    transgrid=rottrans_mat*([Xpixels(:) Ypixels(:) onesmatgrid(:)])';
    transgridx=reshape(transgrid(1,:),size(Image_ref,1),size(Image_ref,2));
    transgridy=reshape(transgrid(2,:),size(Image_ref,1),size(Image_ref,2));
    xshifts=Xpixels-transgridx;
    yshifts=Ypixels-transgridy;


    case 'interpolate'

    %remove values with NaN XCF height
    xShiftsXcf=xShiftsXcf(~isnan(CCmax_1));
    yShiftsXcf=yShiftsXcf(~isnan(CCmax_1));
    roiPosX=roiPosX(~isnan(CCmax_1));
    roiPosY=roiPosY(~isnan(CCmax_1));
    CCmax=CCmax_1(~isnan(CCmax_1));

    % normalise data to avoid scaling artefacts in scatteredInterpolant
    [xPosNorm,cXP,sXP] = normalize(roiPosX(:));
    [yPosNorm,cYP,sYP] = normalize(roiPosY(:));
    [xShiftNorm,cXS,sXS] = normalize(xShiftsXcf(:));
    [yShiftNorm,cYS,sYS] = normalize(yShiftsXcf(:));
    % scale/centring values to undo the normalisation later:
    % N = (A - C) ./ S
    % A = N .* S + C

    % create scattered interpolant object
    xsurf = scatteredInterpolant([xPosNorm,yPosNorm],xShiftNorm,'natural','linear');
    % no need to compute this twice at the same grid points -- copy and
    % overwrite with Shift_X_1 values instead
    % % ysurf = scatteredInterpolant([roiPosX(:),roiPosY(:)],yShiftsXcf(:),'natural','linear');%don't do this
    ysurf = xsurf; ysurf.Values=yShiftNorm;

    %for quiver plot
    xshiftsROI=(xsurf(xPosNorm,yPosNorm) .* sXS) + cXS;
    yshiftsROI=(ysurf(xPosNorm,yPosNorm) .* sYS) + cYS;
    
    % for entire image
     %pixel grid in reference frame
    [Xpixels,Ypixels]=meshgrid(1:size(Image_ref,2),1:size(Image_ref,1));
    % normalise by scaling/centring values for x and y positions
    % before sampling interpolant object
    %pixel shifts in reference frame
    xshifts=(xsurf(...
        (Xpixels - cXP)./sXP,(Ypixels-cYP)./sYP)...
        .* sXS) + cXS;
    yshifts=(ysurf(...
        (Xpixels-cXP)./sXP,(Ypixels-cYP)./sYP)...
        .* sYS) + cYS;
    % undo normalisation to get this back in pixel units
    
    otherwise
    %remove values with NaN XCF height
    xShiftsXcf=xShiftsXcf(~isnan(CCmax_1));
    yShiftsXcf=yShiftsXcf(~isnan(CCmax_1));
%     CCmax=CCmax_1(~isnan(CCmax_1));
    roiPosX=roiPosX(~isnan(CCmax_1));
    roiPosY=roiPosY(~isnan(CCmax_1));
    
    % calculate best fit
    [xsurf, ~]=fit([roiPosX(:),roiPosY(:)],xShiftsXcf(:),fitfunc);
    [ysurf, ~]=fit([roiPosX(:),roiPosY(:)],yShiftsXcf(:),fitfunc);
    
    %for quiver plot
    xshiftsROI=xsurf(roiPosX,roiPosY);
    yshiftsROI=ysurf(roiPosX,roiPosY);
    
    % for entire image
    [Xpixels,Ypixels]=meshgrid(1:size(Image_ref,2),1:size(Image_ref,1)); %pixel grid in reference frame
    xshifts=xsurf(Xpixels,Ypixels); %pixel shifts in reference frame
    yshifts=ysurf(Xpixels,Ypixels);
    
end

%% Pack outputs
disp(['Mean X-shift length ' num2str(mean(abs(xShiftsXcf(:)))) ' pixels']);
disp(['Mean Y-shift length ' num2str(mean(abs(yShiftsXcf(:)))) ' pixels']);
disp(['Mean shift length ' num2str(mean(sqrt(abs(xShiftsXcf(:).^2+abs(yShiftsXcf(:).^2))))) ' pixels']);

% convert to lengths
pix2um = @(dxy,outPix) dxy*outPix;
% create pairShifts object
RegOutput = pairShifts(...
    pix2um(dx,xshifts),   pix2um(dy,yshifts),...
    pix2um(dx,xshiftsROI),pix2um(dy,yshiftsROI),...
    xShiftsXcf, yShiftsXcf, ...
    roiPosX, roiPosY, roiSize);
% RegOutput.x= xshifts;
% RegOutput.y = yshifts;
% RegOutput.xshiftsROI= xshiftsROI;
% RegOutput.yshiftsROI = yshiftsROI;
% RegOutput.ROI = ROI;


